<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>Cpp Primer Chapter 2</title><link rel=stylesheet href=/css/style.css></head><body><header>===================<br>== <a href=https://blog.peterchen.xyz/>颢阳's Blog</a> ==<br>===================<div style=float:right>blog for everything</div><br><p><nav><a href=/><b>Start</b></a>.
<a href=/posts/><b>Posts</b></a>.
<a href=/reads/><b>Reads</b></a>.
<a href=/categories/><b>Categories</b></a>.
<a href=/tags/><b>Tags</b></a>.</nav></p><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}},window.addEventListener('load',a=>{document.querySelectorAll("mjx-container").forEach(function(a){a.parentElement.classList+='has-jax'})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></header><main><article><h1>Cpp Primer Chapter 2</h1><p><b>Posted
on <time>05.26.2021 10:08</time>
in
<a href=/categories/book>book</a></b>
• 3008 words
• 15 minute read<br>Tags:
<a href=/tags/cpp>cpp</a>, <a href=/tags/cpp-primer>cpp primer</a></p><div><h2 id=c-language-specifics>C++ language specifics</h2><p>Python check types at run time, whereas C++ is statically typed language — type-check is done at compile time. As a consequence, the compiler must know the type of every name used in the program.</p><h2 id=primitive-buit-in-types>Primitive Buit-in Types</h2><p>C++ defines a set of primitive types that include the <strong>arithmetic types</strong> and a special type named <strong>void</strong>. The arithmetic types represent characters, integers, boolean values, and floating-point numbers. The void type has no associated values and can be used in only a few circumstances, most commonly as the return type for functions that do not return a value.</p><h3 id=arithmetic-types>Arithmetic Types</h3><ol><li>bool: boolean (NA)</li><li>char: character (8 bits)</li><li>wchar_t: wide character (16 bits)</li><li>char16_t: Unicode character (16 bits)</li><li>char32_t: Unicode character (32 bits)</li><li>short: short integer (16 bits)</li><li>int: integer (16 bits)</li><li>long: long integer (32 bits)</li><li>long long: long integer (64 bits)</li><li>float: single-precision floating-point (6 significant digits)</li><li>double: double-precision floating-point (10 significant digits)</li><li>long double: extended-precision floating-point (10 significant digits)</li></ol><p>Typically, <code>floats</code> are represented in one word (32 bits), <code>doubles</code> in two words (64 bits), and <code>long double</code> in either three or four words (96 or 128 bits). The <code>float</code> and <code>double</code> types typically yield about 7 and 16 significant digits, respectively.</p><p>Except for bool and the extended character types, the integral types may be <strong>signed</strong> or <strong>unsigned</strong>. A signed type represents negative or positive numbers (including zero); an unsigned type represents only values greater than or equal to zero .The type <code>unsigned int</code> may be abbreviated as <code>unsigned</code>.</p><h3 id=a-short-note-to-use-char>A short note to use <code>char</code></h3><p>Do not use plain <code>char</code> or <code>bool</code> in arithmetic expression. Use them <em>only</em> to hold characters or truth values. Computations using <code>char</code> are especially problematic because <code>char</code> is <code>signed</code> on some machine and <code>unsigned</code> on others. If you need a tiny integer, explicitly specify either <code>signed char</code> or <code>unsigned char</code>.</p><h2 id=type-conversion>Type conversion</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>bool</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>; <span style=color:#75715e>// b is true: anything not 0 is true
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> b;   <span style=color:#75715e>// i has value 1
</span><span style=color:#75715e></span>i <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.14</span>;    <span style=color:#75715e>// i has value 3: cast down
</span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> pi <span style=color:#f92672>=</span> i; <span style=color:#75715e>// pi has value 3.0
</span><span style=color:#75715e></span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> c <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// assuming 8-bit chars, c has value 255: there is no negative for unsigned
</span><span style=color:#75715e></span><span style=color:#66d9ef>signed</span> <span style=color:#66d9ef>char</span> c2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>256</span>; <span style=color:#75715e>// assuming 8-bit chars, the value of c2 is undefined
</span></code></pre></div><h3 id=why-unsigned-char-c---1-will-get-255>Why <code>unsigned char c = -1</code> will get 255?</h3><p>If we assign an out-of-range value to an object of unsigned type, the result is the remainder of the value modulo the number of values the target type can hold. For example, an 8-bit unsigned char can hold values from 0 through 255, inclusive. If we assign a value outside this range, the compiler assigns the remainder of that value <strong>modulo</strong> 256. Therefore, assigning –1 to an 8-bit unsigned char gives that object the value 255. Note that modulo mentioned here is <strong>logical, arithmetic modulo operation</strong>:</p><pre><code>a mod n is a/n = r (remainder)
therefore, a mod n = a - r * n
so, -1 mod 256 is
-1/256 = 1
=&gt; -1 - (-1) * 256
=&gt; 255
</code></pre><p>Reference: <a href=https://www.calculators.org/math/modulo.php>https://www.calculators.org/math/modulo.php</a></p><h3 id=dont-use-unsigned-in-loop>Don&rsquo;t use <code>unsigned</code> in loop</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i)
  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</code></pre></div><p>We might think we could rewrite this loop using an unsigned. After all, we don’t plan to print negative numbers. However, this simple change in type means that our loop will never terminate:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>unsigned</span> u <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>; u <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>u)
	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> u <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</code></pre></div><p><code>u</code> can never be less than 0; the condition will always succeed. Consider what happens when <code>u</code> is 0. On that iteration, we’ll print 0 and then execute the expression in the for loop. That expression, <code>—u</code>, subtracts 1 from <code>u</code>. That result, -1, won’t fit in an unsigned value. As with any other out-of-range value, -1 will be transformed to an unsigned value. Assuming 32-bit ints, the result of <code>—u</code>, when <code>u</code> is 0, is 4294967295.</p><h2 id=literal>Literal</h2><p>If we write what appears to be a negative decimal literal, for example, <code>-42</code>, the minus sign is <em>not</em> part of the literal. The minus sign is an <strong>operator</strong> that negates the value of its (literal) operand.</p><p>The type of a string literal is <strong>array</strong> of constant chars:</p><ul><li><code>'a'</code>: character literal</li><li><code>"hello world"</code>: string literal</li></ul><p>Compiler will append a null character ('\0') at the end of every string literal, so the length is always string literal size + 1.</p><h3 id=specify-the-type-of-a-literal>Specify the Type of a Literal</h3><p>We can override the default type of an integer, floating-point, or character literal by supplying a suffix or prefix as listed below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#e6db74>L</span><span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#75715e>// wide character literal, type is wchar_t
</span><span style=color:#75715e></span><span style=color:#e6db74>u8</span><span style=color:#e6db74>&#34;hi!&#34;</span> <span style=color:#75715e>// utf-8 string literal (utf-8 encodes a Unicode character in 8 bits)
</span><span style=color:#75715e></span><span style=color:#ae81ff>42ULL</span> <span style=color:#75715e>// unsigned integer literal, type is unsigned long long 
</span><span style=color:#75715e></span><span style=color:#ae81ff>1E-3</span>F <span style=color:#75715e>// single-precision floating-point literal, type is float 
</span><span style=color:#75715e></span><span style=color:#ae81ff>3.14159</span>L <span style=color:#75715e>// extended-precision floating-point literal, type is long double
</span></code></pre></div><h3 id=default-initialization>Default Initialization</h3><p>Uninitialized objects of built-in type defined inside a function body have undefined value. However, the library string class says that if we do not supply an initializer, then the resulting string is the empty string.</p><h2 id=variable>Variable</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> units_sold <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
<span style=color:#66d9ef>int</span> units_sold{<span style=color:#ae81ff>0</span>};
</code></pre></div><p>The use of curly braces to initialize a variable is called <strong>List Initialization</strong>. The compiler will not let us list initialize variables of built-in type if the initializer might lead to the loss of information:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>double</span> ld <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.1415</span>;
<span style=color:#66d9ef>int</span> a{ld}, b <span style=color:#f92672>=</span> {ld}; <span style=color:#75715e>// error: narrowing conversion required
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>c</span>(ld), d <span style=color:#f92672>=</span> ld;   <span style=color:#75715e>// ok: not using list init but the value will be truncated
</span></code></pre></div><h3 id=reference>Reference</h3><p>When we define a reference, instead of copying the initializer’s value, we <strong>bind</strong> the reference to its initializer.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> ival <span style=color:#f92672>=</span> <span style=color:#ae81ff>1024</span>;
<span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>refVal <span style=color:#f92672>=</span> ival;
cout <span style=color:#f92672>&lt;&lt;</span> refVal <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// 1024
</span><span style=color:#75715e></span>refVal <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
cout <span style=color:#f92672>&lt;&lt;</span> ival <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// 2
</span></code></pre></div><p>When we assign to a reference, we are assigning to the object to which the reference is bound. When we fetch the value of a reference, we are really fetching the value of the object to which the reference is bound. The type of a reference and the object to which the reference refers must match exactly</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>refVal4 <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>; <span style=color:#75715e>// error: initializer must be an object
</span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> dval <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.14</span>;
<span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>refVal5<span style=color:#f92672>=</span>dval;<span style=color:#75715e>// error: initializer must be an int object
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>refVal6; <span style=color:#75715e>// error: a reference must be initialized
</span></code></pre></div><h2 id=pointers>Pointers</h2><p>A pointer holds the address of another object. We get the address of an object by using the address-of operator (the <strong>&</strong> <strong>operator</strong>):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> ival <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>ival; <span style=color:#75715e>// p holds the address of ival; p is a pointer to ival
</span></code></pre></div><p>Because references are <strong>not objects</strong>, they don’t have addresses. Hence, we may not define a pointer to a reference.</p><h3 id=using-a-pointer-to-access-an-object>Using a Pointer to Access an Object</h3><p>When a pointer points to an object, we can use the dereference operator (the * <strong>operator</strong>) to access that object:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> ival <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>ival; <span style=color:#75715e>// p holds the address of ival; p is a pointer to ival 
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p2 <span style=color:#f92672>=</span> ival; <span style=color:#75715e>// illegal to assign an int variable to a pointer
</span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>p; <span style=color:#75715e>// * yields the object to which p points; prints 42
</span></code></pre></div><p>Dereferencing a pointer yields the object to which the pointer points. We can assign to that object by assigning to the result of the dereference:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// * yields the object; we assign a new value to ival through p 
</span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>p;<span style=color:#75715e>// prints 0
</span><span style=color:#75715e></span>
p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>ival; <span style=color:#75715e>// it will pointing to ival&#39;s address
</span></code></pre></div><p><code>*</code> can have multiple meanings:</p><ol><li>After type: <code>int *p</code> means <code>p</code> is a pointer, and it will point to an address</li><li>Everything else: <code>p = &ival</code> means <code>p</code> will point to an object with a referece but <code>p</code> is already declared</li></ol><h3 id=null-pointers>Null Pointers</h3><p>Older programs sometimes use a <strong>preprocessor variable</strong> named NULL, which the <code>cstdlib</code> header defines as 0. Modern C++ programs generally should avoid using NULL and use nullptr instead.</p><h3 id=void-pointers><code>void*</code> Pointers</h3><p>The type <strong>void*</strong> is a special pointer type that can hold the address of any object. Like any other pointer, a void* pointer holds an address, but the type of the object at that address is unknown:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>double</span> obj <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.14</span>, <span style=color:#f92672>*</span>pd <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>obj;
<span style=color:#75715e>// ok: void* can hold the address value of any data pointer type 
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>pv <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>obj; <span style=color:#75715e>// obj can be an object of any type 
</span><span style=color:#75715e></span>pv <span style=color:#f92672>=</span> pd; <span style=color:#75715e>// pv can hold a pointer to any type
</span></code></pre></div><h3 id=difference-between-pointers-and-references>Difference between Pointers and References</h3><h4 id=key-difference>key difference:</h4><ol><li>a reference is another name of an <strong>already existing</strong> object. a pointer is an object in its <strong>own right</strong>.</li><li>Once initialized, a reference remains <strong>bound to</strong> its initial object. There is <strong>no way</strong> to rebind a reference to refer to a different object. a pointer can be <strong>assigned</strong> and <strong>copied</strong>.</li><li>a reference always get the object to which the reference was initially bound. a single pointer can point to <strong>several different objects</strong> over its lifetime.</li><li>a reference must be initialized. a pointer need <strong>not be</strong> initialized at the time it is defined.</li></ol><h2 id=const-qualifier><code>const</code> Qualifier</h2><p>By default, <code>const</code> Objects are local to a file. Sometimes we have a const variable that we want to share across multiple files but whose initializer is not a constant expression. In this case, we don’t want the compiler to generate a separate variable in each file. Instead, we want the const object to behave like other (nonconst) variables. We want to define the const in one file, and declare it in the other files that use that object.</p><p>To define a single instance of a const variable, we use the keyword extern on both its definition and declaration(s):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// file_1.cc defines and initializes a const that is accessible to other files 
</span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> bufSize <span style=color:#f92672>=</span> fcn();
<span style=color:#75715e>// file_1.h
</span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> bufSize;<span style=color:#75715e>// same bufSize as defined in file_1.cc
</span></code></pre></div><p>To share a <code>const</code> object among multiple files, you must define the variable as <code>extern</code>.</p><h3 id=const-and-pointers><code>const</code> and Pointers</h3><p>Like a reference to const, a <strong>pointer to</strong> <strong>const</strong> may not be used to change the object to which the pointer points. We may store the address of a const object only in a pointer to const:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>double</span> pi <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.14</span>; <span style=color:#75715e>// pi is const; its value may not be changed 
</span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>pi; <span style=color:#75715e>// error:ptr is a plain pointer 
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>double</span> <span style=color:#f92672>*</span>cptr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>pi; <span style=color:#75715e>// ok:cptr may point to a double that is const 
</span><span style=color:#75715e></span><span style=color:#f92672>*</span>cptr <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>; <span style=color:#75715e>// error: cannot assign to *cptr
</span></code></pre></div><h3 id=const-pointer><code>const</code> pointer</h3><p>For example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> errNumb <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> curErr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>errNumb; <span style=color:#75715e>// curErr will always point to errNumb 
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>double</span> pi <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.14159</span>;
<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>double</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> pip <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>pi; <span style=color:#75715e>// pip is a const pointer to a const object
</span></code></pre></div><p>In this case, the symbol closest to <code>curErr</code> is const, which means that <code>curErr</code> itself will be a const object. The next symbol in the declarator is *, which means that <code>curErr</code> is a const pointer. Finally, the base type of the declaration completes the type of <code>curErr</code>, which is a const pointer to an object of type int. Similarly, pip is a const pointer to an object of type const double.</p><p>Neither the value of the object addressed by <code>pip</code> nor the address stored in <code>pip</code> can be changed. On the other hand, <code>curErr</code> addresses a plain, nonconst int. You cannot make it point to something else.</p><blockquote><p>Use const pointer to reference the same address in hardware: <a href=https://stackoverflow.com/a/219956>https://stackoverflow.com/a/219956</a></p></blockquote><p>We use the term <strong>top-level</strong> <strong>const</strong> to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a <strong>low-level</strong> <strong>const</strong>. In general, a pointer is usually a <strong>lower-level const</strong>, and the others are <strong>top-level const</strong>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> p1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>i; <span style=color:#75715e>// we can&#39;t change the value of p1; const is top-level
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> c1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>; <span style=color:#75715e>// we cannot change ci; const is top-level
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p2 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>ci; <span style=color:#75715e>// we can change p2; const is low-level
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> p3 <span style=color:#f92672>=</span> p2; <span style=color:#75715e>// right-most const is top-level, left-most is not
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>r <span style=color:#f92672>=</span> ci; <span style=color:#75715e>// const in reference types is always low-level
</span></code></pre></div><h3 id=constexpr-and-constant-expression><code>constexpr</code> and Constant Expression</h3><p>Only <strong>literal</strong> types can be declared by <code>constexpr</code>: arithmetic, reference, and pointer types are literal types. Variables defined inside a function are not stored at a fixed adress, so we cannot use a <code>constexpr</code> pointer to point to such variables. On the other hand, the address of an object defined outside of any function is a constant expression, and so may be used to initialize a constexpr pointer.</p><h2 id=types>Types</h2><p>There are two ways to define type aliasing:</p><ol><li>via <code>typedef</code>: <code>typedef double wages;</code> — wages is a synonym for <code>double</code></li><li>via <strong>alias declaration</strong>: <code>using SI = Sales_item;</code> where <code>Sale_item</code> is a type, and we use <code>using</code> keyword.</li></ol><h3 id=difference-between-decltype-and-auto>Difference between <code>decltype</code> and <code>auto</code></h3><ol><li><code>decltype</code> is the <em>only</em> context in which a variable defined as a reference is not treated as a synonym for the object to which it refers.</li><li><code>decltype</code> needs to deal with parentheses: <code>decltype((i)) d;</code> error: <code>d</code> is <code>int&</code> and must be initialized; <code>decltype(i) e;</code> ok: <code>e</code> is an (uninitialized) <code>int</code></li></ol><h2 id=defining-our-own-data-structures>Defining Our Own Data Structures</h2><p>Defining our <code>Sales_data</code> class:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Sale_data.h
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Sales_data</span> {
  std<span style=color:#f92672>::</span>string bookNo;
  <span style=color:#66d9ef>unsigned</span> units_sold <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>double</span> revenue <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
};
</code></pre></div><blockquote><p>Don&rsquo;t forget the semicolumn at the end of the <code>struct</code> definition</p></blockquote><p>Revisit chapter 1 and we know that each input contains:</p><pre><code>0-201-78345-X 3 20.00
0-201-78345-X 2 25.00
</code></pre><p>An ISBN, the count of how many books were sold, and the price at which each book was sold.</p><h3 id=read-and-add-two-books>Read and add two books</h3><p>Completed code (exercise 2.41):</p><h4 id=read-single-book>Read single book</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Sale_data</span> {
  std<span style=color:#f92672>::</span>string bookNo;
  <span style=color:#66d9ef>unsigned</span> units_sold <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>double</span> revenue <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
  Sale_data book;
  <span style=color:#66d9ef>double</span> price;
  std<span style=color:#f92672>::</span>cin <span style=color:#f92672>&gt;&gt;</span> book.bookNo <span style=color:#f92672>&gt;&gt;</span> book.units_sold <span style=color:#f92672>&gt;&gt;</span> price;
  book.revenue <span style=color:#f92672>=</span> book.units_sold <span style=color:#f92672>*</span> price;
  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> book.bookNo <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> book.units_sold <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> book.revenue
            <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> price;

  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h4 id=read-two-books-and-add-them-together>Read two books and add them together</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Sale_data</span> {
  std<span style=color:#f92672>::</span>string bookNo;
  <span style=color:#66d9ef>unsigned</span> units_sold <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>double</span> revenue <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
  Sale_data book1, book2;
  <span style=color:#66d9ef>double</span> price1, price2;
  std<span style=color:#f92672>::</span>cin <span style=color:#f92672>&gt;&gt;</span> book1.bookNo <span style=color:#f92672>&gt;&gt;</span> book1.units_sold <span style=color:#f92672>&gt;&gt;</span> price1;
  std<span style=color:#f92672>::</span>cin <span style=color:#f92672>&gt;&gt;</span> book2.bookNo <span style=color:#f92672>&gt;&gt;</span> book2.units_sold <span style=color:#f92672>&gt;&gt;</span> price2;
  book1.revenue <span style=color:#f92672>=</span> book1.units_sold <span style=color:#f92672>*</span> price1;
  book2.revenue <span style=color:#f92672>=</span> book2.units_sold <span style=color:#f92672>*</span> price2;

  <span style=color:#66d9ef>if</span> (book1.bookNo <span style=color:#f92672>==</span> book2.bookNo) {
    <span style=color:#66d9ef>unsigned</span> totalCnt <span style=color:#f92672>=</span> book1.units_sold <span style=color:#f92672>+</span> book2.units_sold;
    <span style=color:#66d9ef>double</span> totalRevenue <span style=color:#f92672>=</span> book1.revenue <span style=color:#f92672>+</span> book2.revenue;
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> book1.bookNo <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> totalCnt <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> totalRevenue <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
    <span style=color:#66d9ef>if</span> (totalCnt <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
      std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> totalRevenue <span style=color:#f92672>/</span> totalCnt <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    <span style=color:#66d9ef>else</span>
      std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;(no sales)&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
  } <span style=color:#66d9ef>else</span> {
    std<span style=color:#f92672>::</span>cerr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Data must refer to same ISBN&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// indicate failure
</span><span style=color:#75715e></span>  }
}
</code></pre></div><h4 id=read-multiple-books-and-calculate-the-revenue>Read multiple books and calculate the revenue</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Sale_data</span> {
  std<span style=color:#f92672>::</span>string bookNo;
  <span style=color:#66d9ef>unsigned</span> units_sold <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>double</span> revenue <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
  Sale_data total;
  <span style=color:#66d9ef>double</span> totalPrice;
  <span style=color:#66d9ef>if</span> (std<span style=color:#f92672>::</span>cin <span style=color:#f92672>&gt;&gt;</span> total.bookNo <span style=color:#f92672>&gt;&gt;</span> total.units_sold <span style=color:#f92672>&gt;&gt;</span> totalPrice) {
    total.revenue <span style=color:#f92672>=</span> total.units_sold <span style=color:#f92672>*</span> totalPrice;

    Sale_data trans;
    <span style=color:#66d9ef>double</span> transPrice;
    <span style=color:#66d9ef>while</span> (std<span style=color:#f92672>::</span>cin <span style=color:#f92672>&gt;&gt;</span> trans.bookNo <span style=color:#f92672>&gt;&gt;</span> trans.units_sold <span style=color:#f92672>&gt;&gt;</span> transPrice) {
      trans.revenue <span style=color:#f92672>=</span> trans.units_sold <span style=color:#f92672>*</span> transPrice;

      <span style=color:#66d9ef>if</span> (total.bookNo <span style=color:#f92672>==</span> trans.bookNo) { <span style=color:#75715e>// same book
</span><span style=color:#75715e></span>        total.units_sold <span style=color:#f92672>+=</span> trans.units_sold;
        total.revenue <span style=color:#f92672>+=</span> trans.revenue;
      } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// start calculating new book
</span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> total.bookNo <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> total.units_sold <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>
                  <span style=color:#f92672>&lt;&lt;</span> total.revenue <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
        <span style=color:#66d9ef>if</span> (total.units_sold <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#75715e>// calculate the average revenue
</span><span style=color:#75715e></span>          std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> total.revenue <span style=color:#f92672>/</span> total.units_sold <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
        <span style=color:#66d9ef>else</span>
          std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;(no sales)&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;

        total.bookNo <span style=color:#f92672>=</span> trans.bookNo;
        total.units_sold <span style=color:#f92672>=</span> trans.units_sold;
        total.revenue <span style=color:#f92672>=</span> trans.revenue;
      }
    }

    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> total.bookNo <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> total.units_sold <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> total.revenue
              <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
    <span style=color:#66d9ef>if</span> (total.units_sold <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
      std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> total.revenue <span style=color:#f92672>/</span> total.units_sold <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    <span style=color:#66d9ef>else</span>
      std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;(no sales)&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
  } <span style=color:#66d9ef>else</span> {
    std<span style=color:#f92672>::</span>cerr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;No data?!&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// indicate failure
</span><span style=color:#75715e></span>  }
}

</code></pre></div><p>This program must ensure the input is sorted by <code>bookNo</code>.</p><h2 id=header-files>Header files</h2><p>Some note for writing header files:</p><ol><li>The program that uses the header file will use the already included library (string.h for example).</li><li>Whenever a header is updated, the source files that use that header must be recompiled to get the new or changed declarations.</li></ol><h2 id=terms>Terms</h2><ol><li><p><strong>Escape sequence</strong>: some characters, such as backspace or control characters, have no visible image</p><ol><li>newline: \n</li><li>vertical tab: \v</li><li>baskslash: \</li><li>carriage return: \r</li><li>horizontal tab: \t</li><li>backspace: \b</li><li>question mark: ?</li><li>formfeed: \f</li><li>alert (bell): \a</li><li>double quote: \"</li><li>single quote: \'</li></ol></li><li><p><strong>Separate compilation</strong>: To allow programs to be written in logical parts, C++ supports what is commonly known as <strong>separate compilation</strong>. Separate compilation lets us split our programs into several files, each of which can be compiled independently.</p><ul><li><p>A variable <strong>declaration</strong> specifies the type and name of a variable. A variable <strong>definition</strong> is a declaration. In addition to specifying the name and type, a definition also allocates storage and may provide the variable with an initial value.</p></li><li><p>To use a variable in more than one file requires <strong>declarations</strong> that are separate from the variable’s <strong>definition</strong>. To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files that use that variable must <strong>declare</strong>—but not <strong>define</strong>—that variable.</p></li><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>1024</span>; <span style=color:#75715e>// definition
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> iy; <span style=color:#75715e>// definition
</span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> iz; <span style=color:#75715e>// declaration
</span></code></pre></div></li></ul></li><li><p><strong>Preprocessor</strong>: The preprocessor — which C++ inherits from C — is a program that runs before the compiler and changes the source of text of our programs. C++ programs also use the preprocessor to define <strong>header guards</strong>. Preprocessor variables have one of two possible states: defined or not defined. The <strong>#define</strong> directive takes a name and defines that name as a preprocessor variable. There are two other directives that test whether a given preprocessor variable has or has not been defined: <strong>#ifdef</strong> is true if the variable has been defined, and <strong>#ifndef</strong> is true if the variable has <em>not</em> been defined. If the test is true, then everything following the #ifdef or #ifndef is processed up to the matching <strong>#endif</strong>.</p></li></ol></div></article></main><div><a class=prev href=https://blog.peterchen.xyz/reads/cpp-primer-ch1/ title="Cpp Primer Chapter 1">« Cpp Primer Chapter 1</a>
<a class=next href=https://blog.peterchen.xyz/reads/cpp-primer-ch3/ title="Cpp Primer Chapter 3">Cpp Primer Chapter 3 »</a></div><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/reads/cpp-primer-c5/>Cpp Primer Chapter 5</a></li><li><a href=/reads/cpp-primer-ch4/>Cpp Primer Chapter 4</a></li><li><a href=/reads/cpp-primer-ch3/>Cpp Primer Chapter 3</a></li><li><a href=/reads/cpp-primer-ch2/>Cpp Primer Chapter 2</a></li><li><a href=/reads/cpp-primer-ch1/>Cpp Primer Chapter 1</a></li></ul></div></div></aside><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//blog-zo8ylgqplu.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer><p>&copy; 2021 <a href=https://blog.peterchen.xyz/><b>颢阳</b></a>.
<a href=https://github.com/advpetc><b>Github</b></a>.
<a href=/imprint><b>Imprint</b></a>.</p></footer></body></html>