<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>Cpp Primer Chapter 3</title><link rel=stylesheet href=/css/style.css></head><body><header>===================<br>== <a href=https://blog.peterchen.xyz/>颢阳's Blog</a> ==<br>===================<div style=float:right>blog for everything</div><br><p><nav><a href=/><b>Start</b></a>.
<a href=/posts/><b>Posts</b></a>.
<a href=/reads/><b>Reads</b></a>.
<a href=/categories/><b>Categories</b></a>.
<a href=/tags/><b>Tags</b></a>.</nav></p><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}},window.addEventListener('load',a=>{document.querySelectorAll("mjx-container").forEach(function(a){a.parentElement.classList+='has-jax'})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></header><main><article><h1>Cpp Primer Chapter 3</h1><p><b>Posted
on <time>05.30.2021 10:14</time>
in
<a href=/categories/book>book</a></b>
• 2180 words
• 11 minute read<br>Tags:
<a href=/tags/cpp>cpp</a>, <a href=/tags/cpp-primer>cpp primer</a></p><div><h2 id=namespace-using-declarations>Namespace <code>using</code> Declarations</h2><p>A using declaration lets us use a name from a namespace without qualifying the name with a namespace_name::prefix. A using declaration has the form:</p><p><code>using namespace::name;</code></p><p>For example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> std<span style=color:#f92672>::</span>cin;
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
  <span style=color:#66d9ef>int</span> i;
  cin <span style=color:#f92672>&gt;&gt;</span> i; <span style=color:#75715e>// ok: cin is a synonym for std::cin
</span><span style=color:#75715e></span>  cout <span style=color:#f92672>&lt;&lt;</span> i; <span style=color:#75715e>// error: no using declaration
</span><span style=color:#75715e></span>  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> i; <span style=color:#75715e>// ok
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>Code inside headers ordinarily <strong>should not</strong> use <code>using</code> declarations. The reason is that the contents of a header are copied into the including program’s text. If a header has a <code>using</code> declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn’t intend to use the specified library name might encounter unexpected name conflicts.</p><h2 id=library-string-type>Library <code>string</code> Type</h2><p>We can define a string in following ways:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>string s1; <span style=color:#75715e>// &#34;&#34;
</span><span style=color:#75715e></span>string s2 <span style=color:#f92672>=</span> s2; <span style=color:#75715e>// copy
</span><span style=color:#75715e></span>string s3 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hiya&#34;</span>; <span style=color:#75715e>// literal
</span><span style=color:#75715e></span>string <span style=color:#a6e22e>s4</span>(<span style=color:#ae81ff>10</span>, <span style=color:#e6db74>&#39;c&#39;</span>); <span style=color:#75715e>// &#34;cccccccccc&#34;
</span><span style=color:#75715e></span>string <span style=color:#a6e22e>s5</span>(<span style=color:#e6db74>&#34;hiya&#34;</span>); <span style=color:#75715e>// direct init
</span><span style=color:#75715e></span>string <span style=color:#a6e22e>s6</span>(s2); <span style=color:#75715e>// s6 is a copy of s2
</span></code></pre></div><p>If we use <code>=</code>, then we are doing <strong>copy initialization</strong>. If we don&rsquo;t use <code>=</code>, like s4, we are using <strong>direct initializaiton</strong>.</p><h3 id=read-in-string>Read in <code>string</code></h3><h4 id=reading-an-unknown-number-of-strings>Reading an unknown number of strings:</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
  string word;
  <span style=color:#66d9ef>while</span> (cin <span style=color:#f92672>&gt;&gt;</span> word) <span style=color:#75715e>// read unitl end-of-file
</span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> word <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;+&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;  
  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>This will read until the end of line, and delimited by space or newline.</p><p>Given input:</p><pre><code>a c
b

c
</code></pre><p>Ouptut:</p><pre><code>a+
c+
b+
c+
</code></pre><h4 id=using-getline-to-read-an-entire-line>Using <code>getline</code> to read an entire line:</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
  string line;
  <span style=color:#75715e>// read input a line at a time until end-of-file 
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>while</span> (getline(cin, line))
  	cout <span style=color:#f92672>&lt;&lt;</span> line <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;+&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>This will read until there is a new line, and the space in each line remains.</p><p>Output (with previous input):</p><pre><code>a c+
b+
+
c+
</code></pre><h3 id=adding-literals-and-strings>Adding Literals and <code>strings</code></h3><p>When we mix strings and string or character literals, at least one operand to each + operator must be of string type: <code>string s = "hello" + "world!";</code> is wrong, because there is no <code>string</code> operand. <code>string s = "hello" + ", " + s2;</code> is also wrong, since there is no <code>string</code> operand between <code>"hello"</code> and <code>","</code>.</p><p>How whitespace characters are handled in the string input operator and in the <code>getline</code> function.</p><ul><li>For code like <code>is >> s</code>, input is separated by whitespaces while reading into string <code>s</code>.</li><li>For code like <code>getline(is, s)</code> input is separated by newline <code>\n</code> while reading into string <code>s</code>. Other whitespaces are ignored.</li><li>For code like <code>getline(is, s, delim)</code>input is separated by <code>delim</code> while reading into string <code>s</code>. All whitespaces are ignored.</li></ul><h2 id=library-vector-type>Library <code>vector</code> Type</h2><p>A vector is a <strong>class template</strong>. C++ has both class and function templates. Templates are not themselves functions or classes. Instead, they can be thought of as instructions to the compiler for generating classes or functions. The process that the compiler uses to create classes or functions from templates is called <strong>instantiation</strong>. When we use a template, we specify what kind of class or function we want the compiler to instantiate. We supply it inside a pair of angle brackets following the template’s name: <code>#include &lt;vector>;</code></p><p>Because references are not objects, we cannot have a <code>vector</code> of references.</p><h3 id=defining-and-initializing-vector><strong>Defining and Initializing</strong> <code>vector</code></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ivect; <span style=color:#75715e>// initially empty
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ivec2(ivect); <span style=color:#75715e>// copy elements of ivec to ivec2
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ivec3 <span style=color:#f92672>=</span> ivec; <span style=color:#75715e>// copy elements of ivec to ivec3
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> articles <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#e6db74>&#34;an&#34;</span>, <span style=color:#e6db74>&#34;the&#34;</span>}; <span style=color:#75715e>// with string literal
</span></code></pre></div><p>We cannot supply a list of initializers using parentheses:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> v1{<span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#e6db74>&#34;an&#34;</span>, <span style=color:#e6db74>&#34;the&#34;</span>}; <span style=color:#75715e>// ok: using curly braces
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> v2(<span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#e6db74>&#34;an&#34;</span>, <span style=color:#e6db74>&#34;the&#34;</span>); <span style=color:#75715e>// error: cannot use parentheses
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> v3{<span style=color:#ae81ff>10</span>, <span style=color:#e6db74>&#34;hi&#34;</span>}; <span style=color:#75715e>// equal to v3(10, &#34;hi&#34;);
</span></code></pre></div><p>When we use parentheses, we are saying that the values we supply are to be used to <em>construct</em> the object. When we use curly braces, {&mldr;}, we’re saying that, if possible, we want to <em>list initialize</em> the object.</p><h2 id=introducing-iterators>Introducing Iterators</h2><p>In the case of an iterator, that object is an element in a container or a character in a string. We can use an iterator to fetch an element and iterators have operations to <strong>move</strong> from one element to another. As with pointers, an iterator may be valid or invalid. A valid iterator either denotes an <strong>element</strong> or denotes a <strong>position</strong> one past the last element in a container. All other iterator values are invalid.</p><h3 id=using-iterators>Using iterators</h3><p>Unlike pointers, we do not use the address-of operator to obtain an iterator. Instead, types that have iterators have members that return iterators. In particular, these types have members named <strong>begin</strong> and <strong>end</strong>. The begin member returns an iterator that denotes the first element (or first character), if there is one:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>auto</span> b <span style=color:#f92672>=</span> v.begin(), e <span style=color:#f92672>=</span> v.end(); <span style=color:#75715e>// b and e are the same type
</span></code></pre></div><p>The iterator returned by end is an iterator positioned “one past the end” of the associated container (or string). This iterator denotes a <strong>nonexistent</strong> element “off the end” of the container. It is used as a marker indicating when we have processed all the elements. The iterator returned by end is often referred to as the <strong>off-the-end iterator</strong> or abbreviated as “the end iterator.” If the container is empty, begin returns the same iterator as the one returned by end.</p><p>As with pointers, we can dereference an iterator to obtain the element denoted by an iterator:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>string <span style=color:#a6e22e>s</span>(<span style=color:#e6db74>&#34;some string&#34;</span>);
<span style=color:#66d9ef>if</span> (s.begin() <span style=color:#f92672>!=</span> s.end()) { <span style=color:#75715e>// make sure s is not empty
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> s.begin();
  <span style=color:#f92672>*</span>it <span style=color:#f92672>=</span> toupper(<span style=color:#f92672>*</span>it);
}
</code></pre></div><h3 id=common-iterators-operations>Common Iterators Operations</h3><p><figure><img src=https://i.imgur.com/V86ywPp.png alt=Imgur></figure></p><p>To let us ask specifically for the <code>const_iterator</code> type, the new standard introduced two new functions named <code>cbegin</code> and <code>cend</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v;
<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> v.cbegin(); <span style=color:#75715e>// it has type vector&lt;int&gt;::const_iterator
</span></code></pre></div><p>To simplify the operation of <code>(*it).empty()</code>, c++ introduces a shortcut <code>it -> empty()</code>, and the arrow sign can be applied directly to pointer.</p><h3 id=using-iterator-arithmetic>Using Iterator Arithmetic</h3><p>Using iterator for binary search:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>auto</span> beg <span style=color:#f92672>=</span> text.begin(), end <span style=color:#f92672>=</span> text.end();
<span style=color:#66d9ef>auto</span> mid <span style=color:#f92672>=</span> text.begin() <span style=color:#f92672>+</span> (end <span style=color:#f92672>-</span> beg) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
<span style=color:#66d9ef>while</span> (mid <span style=color:#f92672>!=</span> end <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>*</span>mid <span style=color:#f92672>!=</span> sought) {
  <span style=color:#66d9ef>if</span> (sought <span style=color:#f92672>&lt;</span> <span style=color:#f92672>*</span>mid) 
    end <span style=color:#f92672>=</span> mid;
  <span style=color:#66d9ef>else</span>
    beg <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
  mid <span style=color:#f92672>=</span> beg <span style=color:#f92672>+</span> (end <span style=color:#f92672>-</span> beg) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
}
</code></pre></div><h2 id=arrays>Arrays</h2><p>An array is a data structure that is similar to the library vector type but offers a different trade-off between performance and flexibility. Like a vector, an array is a container of unnamed objects of a single type that we access by position. Unlike a vector, arrays have fixed size; we cannot add elements to an array. Because arrays have fixed size, they sometimes offer better run-time performance for specialized applications. However, that run-time advantage comes at the cost of lost flexibility.</p><h3 id=defining-and-initializing-build-in-arrays>Defining and Initializing Build-in Arrays</h3><p>It requires a <code>constexpr</code> to define an array&rsquo;s size:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>unsigned</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
<span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>unsigned</span> sz <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
<span style=color:#66d9ef>int</span> arr[<span style=color:#ae81ff>10</span>]; <span style=color:#75715e>// ok
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>parr[sz]; <span style=color:#75715e>// ok: array of int pointer
</span><span style=color:#75715e></span>string bad[cnt]; <span style=color:#75715e>// error: cnt isn&#39;t constant expression
</span><span style=color:#75715e></span>string strs[get_size()]; <span style=color:#75715e>// ok if get_size() return a constexpr
</span></code></pre></div><p>Define an array with literals:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>unsigned</span> sz <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
<span style=color:#66d9ef>int</span> al[sz] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>};
<span style=color:#66d9ef>int</span> a2[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>};
<span style=color:#66d9ef>int</span> a3[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}; <span style=color:#75715e>// ok: equivalent to a3[] = {0, 1, 2, 0, 0};
</span><span style=color:#75715e></span>string a4[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;hi&#34;</span>, <span style=color:#e6db74>&#34;bye&#34;</span>}; <span style=color:#75715e>// ok: equivalent to a4[] = {&#34;hi&#34;, &#34;bye&#34;, &#34;&#34;};
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> a5[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}; <span style=color:#75715e>// error: to many initializers
</span></code></pre></div><p>Since String is an array of char, it has its own way of definition:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>char</span> a1[] <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;C&#39;</span>, <span style=color:#e6db74>&#39;+&#39;</span>, <span style=color:#e6db74>&#39;+&#39;</span>}; <span style=color:#75715e>// list init, no null
</span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> a2[] <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;C&#39;</span>, <span style=color:#e6db74>&#39;+&#39;</span>, <span style=color:#e6db74>&#39;+&#39;</span>, <span style=color:#e6db74>&#39;\0&#39;</span>}; <span style=color:#75715e>// list init, explicit null
</span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> a3[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;C++&#34;</span>; <span style=color:#75715e>// null terminator added automatically
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> a4[<span style=color:#ae81ff>6</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Daniel&#34;</span>; <span style=color:#75715e>// error: no space for the null
</span></code></pre></div><p>We cannot initialize an array as a copy of another array, nor is it legal to assign one array to another:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> a[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}; <span style=color:#75715e>// array of three ints
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> a2[] <span style=color:#f92672>=</span> a; <span style=color:#75715e>// error: cannot initialize one array with another 
</span><span style=color:#75715e></span>a2 <span style=color:#f92672>=</span> a; <span style=color:#75715e>// error: cannot assign one array to another
</span></code></pre></div><p>Default values when initialize:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>string sa[<span style=color:#ae81ff>10</span>];      <span style=color:#75715e>//all elements are empty strings
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> ia[<span style=color:#ae81ff>10</span>];         <span style=color:#75715e>//all elements are 0
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    string sa2[<span style=color:#ae81ff>10</span>]; <span style=color:#75715e>//all elements are empty strings
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> ia2[<span style=color:#ae81ff>10</span>];    <span style=color:#75715e>//all elements are undefined
</span><span style=color:#75715e></span>}
</code></pre></div><h3 id=pointers-and-arrays>Pointers and Arrays</h3><p>Arrays have a special property—in most places when we use an array, the compiler automatically substitutes a pointer to the first element:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>string <span style=color:#f92672>*</span>p2 <span style=color:#f92672>=</span> nums; <span style=color:#75715e>// equivalent to p2 = &amp;nums[0]
</span></code></pre></div><h4 id=pointers-are-iterators>Pointers are iterators</h4><p>Using pointers to write a loop to print the elements in <code>arr</code> as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> arr[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>};
<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> arr; <span style=color:#75715e>// pointing at the begining of the arr
</span><span style=color:#75715e></span><span style=color:#f92672>++</span>p; <span style=color:#75715e>// pointing to the second element: for demo purpose
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>e <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>arr[<span style=color:#ae81ff>10</span>]; <span style=color:#75715e>// pointing at the end of the arr
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>b <span style=color:#f92672>=</span> arr; b <span style=color:#f92672>!=</span> e; <span style=color:#f92672>++</span>b) {
  cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>b <span style=color:#f92672>&lt;&lt;</span> endl;
}
</code></pre></div><p>The libray <code>begin()</code> and <code>end()</code> functions</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> ia[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>7</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>9</span>}; <span style=color:#75715e>// ia is an array of ten ints 
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>beg <span style=color:#f92672>=</span> begin(ia); <span style=color:#75715e>// pointer to the first element in ia
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>last <span style=color:#f92672>=</span> end(ia); <span style=color:#75715e>// pointer one past the last element in ia
</span></code></pre></div><p><code>begin</code> returns a pointer to the first, and <code>end</code> returns a pointer one past the last element in the given array: These functions are defined in the <code>iterator</code> header.</p><p>So we can use these two library function to iterate the <code>arr</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// pbeg points to the first and pend points just past the last element in arr 
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>pbeg <span style=color:#f92672>=</span> begin(arr), <span style=color:#f92672>*</span>pend <span style=color:#f92672>=</span> end(arr);
<span style=color:#75715e>// find the first negative element, stopping if we’ve seen all the elements 
</span><span style=color:#75715e></span><span style=color:#66d9ef>while</span> (pbeg <span style=color:#f92672>!=</span> pend <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>*</span>pbeg <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>)
	<span style=color:#f92672>++</span>pbeg;
</code></pre></div><p>The result of subtracting two pointers is a library type named <strong>ptrdiff_t</strong>. Like size_t, the ptrdiff_t type is a machine-specific type and is defined in the cstddef header. Because subtraction might yield a negative distance, ptrdiff_t is a signed integral type.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>auto</span> n <span style=color:#f92672>=</span> end(arr) <span style=color:#f92672>-</span> begin(arr);
</code></pre></div><p>Comparing two vectors:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vec1 <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span> };
vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vec2 <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span> };

<span style=color:#66d9ef>if</span> (vec1 <span style=color:#f92672>==</span> vec2) <span style=color:#75715e>// will compare all the values in two vectors
</span><span style=color:#75715e></span>  cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;The two vectors are equal.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
<span style=color:#66d9ef>else</span>
  cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;The two vectors are not equal.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</code></pre></div><h3 id=c-library-string-functions>C library String Functions</h3><p>The Standard C library provides a set of functions, listed in Table 3.8, that operate on C-style strings. These functions are defined in the cstring header, which is the C++ version of the C header string.h.</p><p><figure><img src=https://i.imgur.com/pTmoRb4.png alt=Imgur></figure></p><p>An easy code snippet for comparing two C-style string:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>cs1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abc&#34;</span>;
<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>cs2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;def&#34;</span>;
<span style=color:#66d9ef>auto</span> result <span style=color:#f92672>=</span> strcmp(cs1, cs2);
<span style=color:#66d9ef>if</span> (result <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
  cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;same strings&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
<span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (result <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
  cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;abc &lt; def&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
<span style=color:#66d9ef>else</span>
  cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;abc &gt; def&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</code></pre></div><h3 id=interfacing-to-older-code>Interfacing to Older Code</h3><p>Many C++ programs predate the standard library and do not use the string and vector types. Moreover, many C++ programs interface to programs written in C or other languages that cannot use the C++ library. Hence, programs written in modern C++ may have to interface to code that uses arrays and/or C-style character strings. The C++ library offers facilities to make the interface easier to manage.</p><p>Transform a string to char array:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>string <span style=color:#a6e22e>s</span>(<span style=color:#e6db74>&#34;hello world&#34;</span>);
<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str <span style=color:#f92672>=</span> s; <span style=color:#75715e>// error:can’t initialize a char* from a string
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str <span style=color:#f92672>=</span> s.c_str(); <span style=color:#75715e>// ok
</span></code></pre></div><p>Transform any array to vector:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> int_arr[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>};
vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ivec(begin(int_arr), end(int_arr));
<span style=color:#75715e>// or just a subset of the array
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> subVec(int_arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, int_arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>);
</code></pre></div><h2 id=multidimensional-arrays>Multidimensional Arrays</h2><h3 id=initialization-the-elements-of-a-multidimensional-array>Initialization the elements of a multidimensional array</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> ia[<span style=color:#ae81ff>3</span>][<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {
  {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>},
  {<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>},
  {<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>11</span>}
};

<span style=color:#75715e>// this is the same as the previous ia, but less readable
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> ia[<span style=color:#ae81ff>3</span>][<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>7</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>11</span>}; 

<span style=color:#66d9ef>int</span> ia[<span style=color:#ae81ff>3</span>][<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>0</span>}, {<span style=color:#ae81ff>4</span>}, {<span style=color:#ae81ff>8</span>}}; <span style=color:#75715e>// we don&#39;t need to fill all the rows
</span><span style=color:#75715e></span>
<span style=color:#75715e>// explicitly initialize row 0; the remaining elements are value initialized 
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> ix[<span style=color:#ae81ff>3</span>][<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>9</span>};
</code></pre></div><p>To use a multidimensional array in a range for, the loop control variable for all but the innermost array must be references.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// this will work, since row is a reference
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>row : ia)
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> col : row)	
    cout <span style=color:#f92672>&lt;&lt;</span> col <span style=color:#f92672>&lt;&lt;</span> endl;

<span style=color:#75715e>// this will not work, since row is a pointer
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> row : ia)
	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> col : row)
</code></pre></div><h2 id=term>Term</h2><ol><li><p><code>std::size_type</code>: The string class—and most other library types—defines several companion types. These companion types make it possible to use the library types in a machine-independent manner. The type <strong>size_type</strong> is one of these companion types. To use the size_type defined by string, we use the scope operator to say that the name size_type is defined in the string class. Although we don’t know the precise type of string::size_type, we do know that it is an <code>unsigned</code> type big enough to hold the size of any string.</p></li><li><p><code>cctype</code> funtions:<figure><img src=https://i.imgur.com/nhe7SUz.png alt></figure></p></li></ol></div></article></main><div><a class=prev href=https://blog.peterchen.xyz/reads/cpp-primer-ch2/ title="Cpp Primer Chapter 2">« Cpp Primer Chapter 2</a>
<a class=next href=https://blog.peterchen.xyz/reads/cpp-primer-ch4/ title="Cpp Primer Chapter 4">Cpp Primer Chapter 4 »</a></div><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/reads/cpp-primer-c5/>Cpp Primer Chapter 5</a></li><li><a href=/reads/cpp-primer-ch4/>Cpp Primer Chapter 4</a></li><li><a href=/reads/cpp-primer-ch3/>Cpp Primer Chapter 3</a></li><li><a href=/reads/cpp-primer-ch2/>Cpp Primer Chapter 2</a></li><li><a href=/reads/cpp-primer-ch1/>Cpp Primer Chapter 1</a></li></ul></div></div></aside><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//blog-zo8ylgqplu.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer><p>&copy; 2021 <a href=https://blog.peterchen.xyz/><b>颢阳</b></a>.
<a href=https://github.com/advpetc><b>Github</b></a>.
<a href=/imprint><b>Imprint</b></a>.</p></footer></body></html>