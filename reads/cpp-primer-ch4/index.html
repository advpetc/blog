<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>Cpp Primer Chapter 4</title><link rel=stylesheet href=/css/style.css></head><body><header>===================<br>== <a href=https://blog.peterchen.xyz/>颢阳's Blog</a> ==<br>===================<div style=float:right>blog for everything</div><br><p><nav><a href=/><b>Start</b></a>.
<a href=/posts/><b>Posts</b></a>.
<a href=/reads/><b>Reads</b></a>.
<a href=/categories/><b>Categories</b></a>.
<a href=/tags/><b>Tags</b></a>.</nav></p><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}},window.addEventListener('load',a=>{document.querySelectorAll("mjx-container").forEach(function(a){a.parentElement.classList+='has-jax'})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></header><main><article><h1>Cpp Primer Chapter 4</h1><p><b>Posted
on <time>06.08.2021 11:16</time>
in
<a href=/categories/tech>tech</a></b>
• 2223 words
• 11 minute read<br>Tags:
<a href=/tags/cpp>cpp</a>, <a href=/tags/cpp-primer>cpp primer</a></p><div><p>This chapter talks about <em>expression</em>, which is composed of one or more <strong>operands</strong> and yields <strong>result</strong> when it is evaluated. The simplest form of an <strong>expression</strong> is a single literal or variable. The result of such an expression is the value of the variable or literal. More complicated expressions are formed from an <strong>operator</strong> and one or more operands.</p><h2 id=fundamentals>Fundamentals</h2><h3 id=precedence-and-associativity>Precedence and Associativity</h3><p>Operands of operators with higher precedence group more tightly than operands of operators at lower precedence. Associativity determines how to group operands with the same precedence. The arithmetic operators are left associative, which means operators at the same precdence group left to right:</p><ul><li>Because of precedence, the expression 3+4*5 is 23, not 35.</li><li>Because of associativity, the expression 20-15-3 is 2, not 8.</li></ul><h3 id=order-of-evaluation>Order of Evaluation</h3><p>For operators that do not specify evaluation order, it is an error for an expression to <em>refer to and change</em> the same object.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
cout <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>++</span>i <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// undefined
</span></code></pre></div><p>Because this program is undefined, we cannot draw any conclusions about how it might behave. The compiler might evaluate ++i before evaluating i, in which case the output will be 1 1. Or the compiler might evaluate i first, in which case the output will be 0 1. <em>Or the compiler might do something else entirely.</em> Because this expression has undefined behavior, the program is in error, regardless of what code the compiler generates.</p><p>There are four operators that do guarantee the order in which operands are evaluated. We saw in § 3.2.3 (p. 94) that the logical AND (&&) operator guarantees that its left-hand operand is evaluated first. Moreover, we are also guaranteed that the right-hand operand is evaluated only if the left-hand operand is true. The only other operators that guarantee the order in which operands are evaluated are the logical OR (||) operator (§ 4.3, p. 141), the conditional (?:) operator (§ 4.7, p. 151), and the comma (,) operator (§ 4.10, p. 157).</p><h2 id=arithmetic-operators>Arithmetic Operators</h2><p><figure><img src=resources/1.png alt=1></figure></p><p>These operators are all left associative, meaning that they group left to right when the precedence levels are the same.</p><p><strong>A note on modulus and division operators</strong></p><p>The modulus operator is defined so that if m and n are integers and n is <strong>nonzero</strong>, then (m/n)*n + m%n is equal to m. By implication, <strong>if m%n is nonzero, it has the same sign as m</strong>. Earlier versions of the language permitted m%n to have the same sign as n on implementations in which negative m/n was rounded away from zero, but such implementations are now prohibited. Moreover, except for the obscure case where -m overflows, <strong>(-m)/n and m/(-n) are always equal to -(m/n)</strong>, <strong>m%(-n) is equal to m%n</strong>, <strong>(-m)%n is equal to -(m%n)</strong>. Division between integers returns an integer. If the quotient contains a fractional part, it is <strong>truncated toward zero</strong>. More concretely:</p><pre><code>21%6; /* result is 3 */
21%7; /* result is 0 */ 
-21%-8; /* result is -5 */ 
21%-5; /* result is 1 */
21/6; /* result is 3 */
21/7; /* result is 3 */ 
-21/-8; /* result is 2 */ 
21/-5; /* result is -4 */
</code></pre><h2 id=logical-and-relational-operators>Logical and Relational Operators</h2><p><figure><img src=resources/2.png alt=2></figure></p><blockquote><p>list of all logical and relational operators</p></blockquote><h3 id=short-circuit-evaluation>Short-circuit evaluation</h3><ul><li>The right side of an && is evaluated if and only if the left side is true.</li><li>The right side of an || is evaluated if and only if the left side is false.</li></ul><h2 id=assignment-operators>Assignment Operators</h2><p><strong>Multiple assignment</strong>: each object in a multiple assignment must have the same type as its right-hand neighbor or a type to which that neighbor can be converted.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> ival, <span style=color:#f92672>*</span>pval; <span style=color:#75715e>// ival is an int; pval is a pointer to int
</span><span style=color:#75715e></span>ival <span style=color:#f92672>=</span> pval <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// error: cannot assign the value of a pointer to an int
</span><span style=color:#75715e></span>string s1, s2;
s1 <span style=color:#f92672>=</span> s2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;OK&#34;</span>; <span style=color:#75715e>// string literal &#34;OK&#34; converted to string
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> i;
<span style=color:#66d9ef>double</span> d;
d <span style=color:#f92672>=</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.5</span>; <span style=color:#75715e>// d: 3.0, i: 3
</span><span style=color:#75715e></span>i <span style=color:#f92672>=</span> d <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.5</span>; <span style=color:#75715e>// d: 3.5, i: 3
</span></code></pre></div><p>Note the last example: Assignment is right associative.</p><h2 id=increment-and-decrement-operators>Increment and Decrement Operators</h2><p>The prefix version avoids unnecessary work. It increments the value and returns the incremented version. The postfix operator must store the original value so that it can return the unincremented value as its result. If we don’t need the unincremented value, there’s no need for the extra work done by the postfix operator.</p><p>For <code>int</code>s and pointers, the compiler can optimize away this extra work. For more complicated iterator types, this extra work potentially might be more costly. By habitually using the prefix versions, we do not have to worry about whether the performance difference matters. Moreover—and perhaps more importantly—we can express the intent of our programs more directly.</p><h3 id=combining-dereference-and-increment-in-a-single-expression>Combining Dereference and Increment in a Single Expression</h3><p>The postfix versions of ++ and &ndash; are used when we want to use the current value of a variable and increment it in a single compound expression.</p><p>As one example, we can use postfix increment to write a loop to print the values in a vector up to but not including the first negative value:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>auto</span> p <span style=color:#f92672>=</span> v.begin();
<span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> v.end())
  cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>p<span style=color:#f92672>++</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</code></pre></div><p>The precedence of postfix increment is higher than that of the deference operator, so <code>*p++</code> is equivalent to <code>*(p++)</code>. The statement prints the element to which pbeg originally pointed and increments pbeg.</p><h2 id=the-conditional-operator>The Conditional Operator</h2><p>The conditional operator (the <strong>?:</strong> <strong>operator</strong>) lets us embed simple if-else logic inside an expression. The conditional operator has the following form:</p><pre><code>cond ? expr1 : expr2;
</code></pre><p>This operator executes by evaluating <em>cond</em>. If the condition is true, then <em>expr1</em> is evaluated; otherwise, <em>expr2</em> is evaluated.</p><h3 id=nesting-conditional-operations>Nesting Conditional Operations</h3><p>We can nest one conditional operator inside another. That is, the conditional operator can be used as the <em>cond</em> or as one or both of the <em>expr</em>s of another conditional expression. As an example, we’ll use a pair of nested conditionals to perform a three-way test to indicate whether a grade is a high pass, an ordinary pass, or fail:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>finalGrade <span style=color:#f92672>=</span> (grade <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>90</span>) <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;high pass&#34;</span> <span style=color:#f92672>:</span> (grade <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>60</span>) <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;fail&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;pass&#34;</span>;
</code></pre></div><p>The conditional operator is right associative, meaning (as usual) that the operands group right to left.</p><h3 id=using-a-conditional-operator-in-an-output-expression>Using a Conditional Operator in an Output Expression</h3><p>The conditional operator has fairly low precedence. When we embed a conditional expression in a larger expression, we usually must parenthesize the conditional subexpression. For example, we often use the conditional operator to print one or another value, depending on the result of a condition. An incompletely parenthesized conditional operator in an output expression can have surprising results:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>cout <span style=color:#f92672>&lt;&lt;</span> ((grade <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>60</span>) <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;fail&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;pass&#34;</span>);  <span style=color:#75715e>// prints pass or fail
</span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> (grade <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>60</span>) <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;fail&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;pass&#34;</span>;    <span style=color:#75715e>// prints 1 or 0!
</span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> grade <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>60</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;fail&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;pass&#34;</span>;      <span style=color:#75715e>// error: compares cout to 60
</span></code></pre></div><h2 id=the-bitwise-operators>The Bitwise Operators</h2><p><figure><img src=resources/3.png alt=x></figure></p><p><strong>Note</strong>: Because there are no guarantees for how the sign bit is handled, we strongly recommend using unsigned types with the bitwise operators.</p><p>The left-shift operator (the <strong>&#171;</strong> <strong>operator</strong>) inserts 0-valued bits on the right. The behavior of the right-shift operator (the <strong>&#187;</strong> <strong>operator</strong>) depends on the type of the left-hand operand: If that operand is unsigned, then the operator inserts 0-valued bits on the left; if it is a signed type, the result is implementation defined—either copies of the sign bit or 0-valued bits are inserted on the left.</p><p>The shift operators have midlevel precedence: lower than the arithmetic operators but higher than the relational, assignment, and conditional operators. These relative precedence levels mean we usually have to use parentheses to force the correct grouping of operators with lower precedence.</p><h2 id=the-sizeof-operator>The <code>sizeof</code> Operator</h2><p>The <code>sizeof</code> operator returns the size, in bytes, of an expression or a type name. The operator is right associative. The result of <code>sizeof</code> is a constant expression (§ 2.4.4, p. 65) of type <code>size_t</code>. The operator takes one of two forms:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>sizeof</span> (type);
<span style=color:#66d9ef>sizeof</span> expr;
</code></pre></div><p><strong>What is <code>sizeof</code> to a pointer?</strong></p><ul><li>sizeof a pointer returns the size needed hold a pointer.</li><li>sizeof a dereferenced pointer returns the size of an object of the type to which the pointer points; the pointer need not be valid.</li></ul><p><strong>Other useful trick with <code>sizeof</code>:</strong></p><ul><li>sizeof an array is the size of the <strong>entire array</strong>. It is equivalent to taking the sizeof the element type times the number of elements in the array. Note that sizeof does not convert the array to a pointer.</li><li>sizeof a string or a vector returns only the size of the fixed part of these types; it does not return the size used by the object’s elements.</li><li>sizeof char or an expression of type char is guaranteed to be 1.</li></ul><p><strong>So we can use <code>sizeof</code> to determine how many items are there in the array:</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>constexpr</span> size_t sz <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(ia) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>ia); <span style=color:#75715e>// return how many items in ia array
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> arr[sz];
</code></pre></div><h2 id=type-conversion>Type Conversion</h2><h3 id=implicit-conversions>Implicit Conversions</h3><p>The implicit conversions among the arithmetic types are defined to preserve precision, if possible. Most often, if an expression has both integral and floating-point operands, the integer is converted to floating-point. In this case, 3 is converted to double, floating-point addition is done, and the result is a double.</p><p>The compiler automatically converts operands in the following circumstances:</p><ul><li>In most expressions, values of integral types smaller than int are first promoted to an appropriate larger integral type.</li><li>In conditions, nonbool expressions are converted to bool.</li><li>In initializations, the initializer is converted to the type of the variable; in assignments, the right-hand operand is converted to the type of the left-hand.</li><li>In arithmetic and relational expressions with operands of mixed types, the types are converted to a common type.</li><li>As we’ll see in Chapter 6, conversions also happen during function calls.</li></ul><h3 id=explicit-conversions>Explicit Conversions</h3><p>Sometimes we want to explicitly force an object to be converted to a different type. For example, we might want to use floating-point division in the following code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> i, j;
<span style=color:#66d9ef>double</span> slope <span style=color:#f92672>=</span> i <span style=color:#f92672>/</span> j;
</code></pre></div><p><strong>Although necessary at times, casts are inherently dangerous constructs.</strong></p><h4 id=name-casts>Name Casts</h4><p>A named cast has the following form:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>cast<span style=color:#f92672>-</span>name<span style=color:#f92672>&lt;</span>type<span style=color:#f92672>&gt;</span>(expression);
</code></pre></div><p><code>static_cast</code></p><p>Any well-defined type conversion, other than those involving low-level const, can be requested using a static_cast. For example, we can force our expression to use floating-point division by casting one of the operands to double:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>double</span> slope <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span>(j) <span style=color:#f92672>/</span> i;
</code></pre></div><p>A static_cast is often useful when a larger arithmetic type is assigned to a smaller type. The cast informs both the reader of the program and the compiler that we are aware of and are not concerned about the potential loss of precision. Compilers often generate a warning for assignments of a larger arithmetic type to a smaller type. When we do an explicit cast, the warning message is turned off.</p><p>A static_cast is also useful to perform a conversion that the compiler will not generate automatically. For example, we can use a static_cast to retrieve a pointer value that was stored in a void* pointer:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>d;
<span style=color:#66d9ef>double</span> <span style=color:#f92672>*</span>dp <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>*&gt;</span>(p);
</code></pre></div><p><code>const_cast</code></p><p>Remove const modifier (for low-level const: Low-level const appears in the base type of compound types such as pointers or references):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>pc;
<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#66d9ef>const_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>*&gt;</span>(pc);
</code></pre></div><p>But we cannot change the type of an expression:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>cp;
<span style=color:#75715e>// error: static_cast can’t cast away
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>q <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>*&gt;</span>(cp);
<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span>(cp); <span style=color:#75715e>// ok: converts string literal to string 
</span><span style=color:#75715e></span><span style=color:#66d9ef>const_cast</span><span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span>(cp); <span style=color:#75715e>// error: const_cast only changes constness
</span></code></pre></div><p><code>reinterpret_cast</code></p><p><code>reinterpret_cast</code> only guarantees that if you cast a pointer to a different type, <em>and then <code>reinterpret_cast</code> it back to the original type</em>, you get the original value. So in the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>();
<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> b <span style=color:#f92672>=</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>*&gt;</span>(a);
<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> c <span style=color:#f92672>=</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>*&gt;</span>(b);
</code></pre></div><p><code>a</code> and <code>c</code> contain the same value, but the value of <code>b</code> is unspecified. (in practice it will typically contain the same address as <code>a</code> and <code>c</code>, but that&rsquo;s not specified in the standard, and it may not be true on machines with more complex memory systems.)</p><p>For casting to and from <code>void*</code>, <code>static_cast</code> should be preferred. Using <code>reinterpret_cast</code> is dangerous.</p><h4 id=exercise>Exercise</h4><p><figure><img src=resources/4.png alt="Screen Shot 2021-06-10 at 9.54.37 AM"></figure></p><p><strong>Answer</strong>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> i; <span style=color:#66d9ef>double</span> d; <span style=color:#66d9ef>const</span> string <span style=color:#f92672>*</span>ps; <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>pc; <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>pv;
pv <span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)ps; <span style=color:#75715e>// pv = const_cast&lt;string*&gt;(ps); or pv = static_cast&lt;void*&gt;(const_cast&lt;string*&gt;(ps));
</span><span style=color:#75715e></span>i <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(<span style=color:#f92672>*</span>pc);   <span style=color:#75715e>// i = static_cast&lt;int&gt;(*pc);
</span><span style=color:#75715e></span>pv <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>d;        <span style=color:#75715e>// pv = static_cast&lt;void*&gt;(&amp;d);
</span><span style=color:#75715e></span>pc <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)pv; <span style=color:#75715e>// pc = static_cast&lt;char*&gt;(pv);
</span></code></pre></div><h2 id=terms>Terms</h2><ol><li><strong>Overload operators</strong>: The language defines what the operators mean when applied to built-in and compound types. We can also define what most operators mean when applied to class types. Because such definitions give an alternative meaning to an existing operator symbol, we refer to them as <strong>overloaded operators</strong>. The IO library &#187; and &#171; operators and the operators we used with strings, vectors, and iterators are all overloaded operators.</li><li><strong>operands</strong>: Values on which an expression operates. Each operator has one or more operands associated with it.</li><li><strong>operator</strong>: Symbol that determines what action an expression performs. The language defines a set of operators and what those operators mean when applied to values of built-in type. The language also defines the precedence and associativity of each operator and specifies how many operands each operator takes. Operators may be overloaded and applied to values of class type.</li><li><strong>Operator Precedence Table</strong>: Refer <a href=https://en.cppreference.com/w/c/language/operator_precedence>here</a></li></ol></div></article></main><div><a class=prev href=https://blog.peterchen.xyz/reads/cpp-primer-ch3/ title="Cpp Primer Chapter 3">« Cpp Primer Chapter 3</a></div><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/reads/cpp-primer-ch4/>Cpp Primer Chapter 4</a></li><li><a href=/reads/cpp-primer-ch3/>Cpp Primer Chapter 3</a></li><li><a href=/reads/cpp-primer-ch2/>Cpp Primer Chapter 2</a></li><li><a href=/reads/cpp-primer-ch1/>Cpp Primer Chapter 1</a></li><li><a href=/posts/%E8%B4%A9%E5%8D%96%E7%84%A6%E8%99%91%E6%95%99%E7%A8%8B/>贩卖焦虑教程</a></li></ul></div></div></aside><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//blog-zo8ylgqplu.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer><p>&copy; 2021 <a href=https://blog.peterchen.xyz/><b>颢阳</b></a>.
<a href=https://github.com/advpetc><b>Github</b></a>.
<a href=/imprint><b>Imprint</b></a>.</p></footer></body></html>